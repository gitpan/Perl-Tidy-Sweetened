.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PP 3"
.TH PP 3 "2003-08-28" "perl v5.14.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Clone::PP \- Recursively copy Perl datatypes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Clone::PP qw(clone);
\&  
\&  $item = { \*(Aqfoo\*(Aq => \*(Aqbar\*(Aq, \*(Aqmove\*(Aq => [ \*(Aqzig\*(Aq, \*(Aqzag\*(Aq ]  };
\&  $copy = clone( $item );
\&
\&  $item = [ \*(Aqalpha\*(Aq, \*(Aqbeta\*(Aq, { \*(Aqgamma\*(Aq => \*(Aqvlissides\*(Aq } ];
\&  $copy = clone( $item );
\&
\&  $item = Foo\->new();
\&  $copy = clone( $item );
.Ve
.PP
Or as an object method:
.PP
.Vb 2
\&  require Clone::PP;
\&  push @Foo::ISA, \*(AqClone::PP\*(Aq;
\&  
\&  $item = Foo\->new();
\&  $copy = $item\->clone();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a general-purpose clone function to make deep
copies of Perl data structures. It calls itself recursively to copy
nested hash, array, scalar and reference types, including tied
variables and objects.
.PP
The \fIclone()\fR function takes a scalar argument to copy. To duplicate
arrays or hashes, pass them in by reference:
.PP
.Vb 2
\&  my $copy = clone(\e@array);    my @copy = @{ clone(\e@array) };
\&  my $copy = clone(\e%hash);     my %copy = %{ clone(\e%hash) };
.Ve
.PP
The \fIclone()\fR function also accepts an optional second parameter that
can be used to limit the depth of the copy. If you pass a limit of
0, clone will return the same value you supplied; for a limit of
1, a shallow copy is constructed; for a limit of 2, two layers of
copying are done, and so on.
.PP
.Vb 1
\&  my $shallow_copy = clone( $item, 1 );
.Ve
.PP
To allow objects to intervene in the way they are copied, the
\&\fIclone()\fR function checks for a couple of optional methods. If an
object provides a method named \f(CW\*(C`clone_self\*(C'\fR, it is called and the
result returned without further processing. Alternately, if an
object provides a method named \f(CW\*(C`clone_init\*(C'\fR, it is called on the
copied object before it is returned.
.SH "BUGS"
.IX Header "BUGS"
Some data types, such as globs, regexes, and code refs, are always copied shallowly.
.PP
References to hash elements are not properly duplicated. (This is why two tests in t/dclone.t that are marked \*(L"todo\*(R".) For example, the following test should succeed but does not:
.PP
.Vb 6
\&  my $hash = { foo => 1 }; 
\&  $hash\->{bar} = \e{ $hash\->{foo} }; 
\&  my $copy = clone( \e%hash ); 
\&  $hash\->{foo} = 2; 
\&  $copy\->{foo} = 2; 
\&  ok( $hash\->{bar} == $copy\->{bar} );
.Ve
.PP
To report bugs via the \s-1CPAN\s0 web tracking system, go to 
\&\f(CW\*(C`http://rt.cpan.org/NoAuth/Bugs.html?Dist=Clone\-PP\*(C'\fR or send mail 
to \f(CW\*(C`Dist=Clone\-PP#rt.cpan.org\*(C'\fR, replacing \f(CW\*(C`#\*(C'\fR with \f(CW\*(C`@\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For a faster implementation in \s-1XS\s0, see \*(L"clone\*(R" in Clone, \*(L"clone\*(R" in Util, or <Storable/dclone>.
.SH "CREDITS AND COPYRIGHT"
.IX Header "CREDITS AND COPYRIGHT"
Developed by Matthew Simon Cavalletto at Evolution Softworks. 
More free Perl software is available at \f(CW\*(C`www.evoscript.org\*(C'\fR.
.PP
Copyright 2003 Matthew Simon Cavalletto. You may contact the author
directly at \f(CW\*(C`evo@cpan.org\*(C'\fR or \f(CW\*(C`simonm@cavalletto.org\*(C'\fR.
.PP
Code initially derived from Ref.pm. Portions Copyright 1994 David Muir Sharnoff.
.PP
Interface based by Clone by Ray Finch with contributions from chocolateboy.
Portions Copyright 2001 Ray Finch. Portions Copyright 2001 chocolateboy.
.PP
You may use, modify, and distribute this software under the same terms as Perl.
